<!--elice_3_33.html-->
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>elcie_3_33.html</title>
</head>
<body>
<div class="instruction-content" data-reactid=".0.3.0.0.0.1.$0.0.0"><h2 id="advancedkmeansvsdbscan1">Advanced: K-Means vs. DBScan (1)</h2>

<p>이번 과제에서는 K-Means 알고리즘의 약점에 대해서 살펴보겠습니다.
해당 알고리즘은 중앙점을 정한 후 각 데이터마다 가장 가까운 중앙점의 클러스터에 속합니다.
그러한 방법으로 할 때 작동하지 않는 경우를 살펴보겠습니다.
또한, 클러스터의 개수가 잘못되었을 때도 어떻게 되는지 살펴보겠습니다.</p>

<h2 id="">과제</h2>

<p>이번 과제에서는 인위적으로 만든 데이터를 분석하여 클러스터를 찾아내도록 하겠습니다.
데이터로는 두 개의 원 모양 (<code>noisy_circles</code>)과 세 개의 물방울 모양 (<code>blobs</code>)입니다.
데이터 분포는 다음과 같습니다.</p>

<p align="center"><img src="http://i.imgur.com/YGFnTnt.png"></p>

<ol>
<li>Pandas를 이용하여 두 개의 데이터를 읽습니다.
<code>noisy_circles</code>은 <code>noisy_circle.csv</code> 파일에, <code>blobs</code>는 <code>blobs.csv</code> 파일에 저장되어 있습니다. 해당 파일을 Pandas의 <code>read_csv()</code> 함수를 이용해 파일을 읽어들여 데이터 프레임으로 저장할 수 있습니다.</li>
<li>읽어들인 데이터에 대해 K-means 알고리즘을 실행합니다.
K-means의 클러스터 개수는 <code>run_kmeans</code> 함수의 파라미터인 <code>num_clusters</code> 값을 전달합니다.
마지막으로 K-means 알고리즘의 결과를 반환합니다.
<ul>
<li><strong>주의 1:</strong> 이전 예제에서 <code>classifier</code> 에 해당하는 KMeans 자체를 리턴해야 합니다.</li>
<li><strong>주의 2:</strong> main 함수에 있는 <code>np.random.seed(108)</code> 을 수정하면 안 됩니다.</li>
<li><strong>주의 3:</strong> 이전 연습에 있던 클러스터 시작점들 (initial_centroids) 는 넣지 않아야 합니다. 앞으로의 연습에서도 마찬가지입니다.</li></ul></li>
<li>K-means를 실행할 데이터를 데이터 프레임에서 추출합니다.
제공되는 데이터 프레임은 첫 번째 열에는 각 데이터의 클래스 정보가 있습니다. 두, 세번째 열에는 각 점의 X축과 Y축 값이 적혀 있습니다.
<ul>
<li>데이터셋의 클래스 정보를 <code>y</code> 변수에 저장합니다.</li>
<li>데이터셋의 각각 데이터 포인트의 위치, 즉 [1, 2] 번째 인덱스에 있는 (x, y) 값들을 <code>X</code> 변수에 저장합니다. 이 (x, y) 값들은 run_kmeans 에 넘겨지게 됩니다.</li></ul></li>
</ol>

<h3 id="-1">입력</h3>

<h4 id="-2">데이터 프레임 일부</h4>

<pre><code>[[ 0.         -1.43415665  0.94938196]
 [ 1.          0.33341044  0.7531304 ]
 [ 1.          0.54022162  0.57801316]
 ...,
 [ 1.         -0.58410983 -0.66764867]
 [ 0.         -1.60622418 -0.76231783]
 [ 0.         -0.64604726 -1.45921285]]
</code></pre></div>
</body>
</html>